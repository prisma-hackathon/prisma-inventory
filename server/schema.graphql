### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

enum Floor {
  EXECUTIVE
  FIRST
  GROUND
}

type Invoice {
  date: DateTime!
  id: ID!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
}

input InvoiceCreateInput {
  date: DateTime!
  id: ID
  items: ItemCreateManyWithoutItemsInput
}

input InvoiceCreateOneWithoutInvoiceInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutItemsInput
}

input InvoiceCreateWithoutItemsInput {
  date: DateTime!
  id: ID
}

input InvoiceUpdateInput {
  date: DateTime
  id: ID
  items: ItemUpdateManyWithoutInvoiceInput
}

input InvoiceUpdateManyMutationInput {
  date: DateTime
  id: ID
}

input InvoiceUpdateOneWithoutItemsInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: InvoiceUpdateWithoutItemsDataInput
  upsert: InvoiceUpsertWithoutItemsInput
}

input InvoiceUpdateWithoutItemsDataInput {
  date: DateTime
  id: ID
}

input InvoiceUpsertWithoutItemsInput {
  create: InvoiceCreateWithoutItemsInput!
  update: InvoiceUpdateWithoutItemsDataInput!
}

input InvoiceWhereInput {
  AND: [InvoiceWhereInput!]
  date: DateTimeFilter
  id: StringFilter
  items: ItemFilter
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
}

input InvoiceWhereUniqueInput {
  id: ID
}

type Item {
  createdAt: DateTime!
  id: ID!
  invoice: Invoice
  locatedIn: Room
  name: String!
  price: Float!
  purchaseDate: DateTime!
  type: ItemType!
  updatedAt: DateTime!
}

input ItemCreateInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceCreateOneWithoutInvoiceInput
  locatedIn: RoomCreateOneWithoutLocatedInInput
  name: String!
  price: Float!
  purchaseDate: DateTime!
  type: ItemTypeCreateOneWithoutTypeInput!
  updatedAt: DateTime
}

input ItemCreateManyWithoutItemsInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutInvoiceInput!]
}

input ItemCreateWithoutInvoiceInput {
  createdAt: DateTime
  id: ID
  locatedIn: RoomCreateOneWithoutLocatedInInput
  name: String!
  price: Float!
  purchaseDate: DateTime!
  type: ItemTypeCreateOneWithoutTypeInput!
  updatedAt: DateTime
}

input ItemCreateWithoutLocatedInInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceCreateOneWithoutInvoiceInput
  name: String!
  price: Float!
  purchaseDate: DateTime!
  type: ItemTypeCreateOneWithoutTypeInput!
  updatedAt: DateTime
}

input ItemCreateWithoutTypeInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceCreateOneWithoutInvoiceInput
  locatedIn: RoomCreateOneWithoutLocatedInInput
  name: String!
  price: Float!
  purchaseDate: DateTime!
  updatedAt: DateTime
}

input ItemFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  price: FloatFilter
  purchaseDate: DateTimeFilter
  updatedAt: DateTimeFilter
}

type ItemType {
  id: ID!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
  name: String!
}

input ItemTypeCreateInput {
  id: ID
  items: ItemCreateManyWithoutItemsInput
  name: String!
}

input ItemTypeCreateOneWithoutTypeInput {
  connect: ItemTypeWhereUniqueInput
  create: ItemTypeCreateWithoutItemsInput
}

input ItemTypeCreateWithoutItemsInput {
  id: ID
  name: String!
}

input ItemTypeUpdateInput {
  id: ID
  items: ItemUpdateManyWithoutTypeInput
  name: String
}

input ItemTypeUpdateManyMutationInput {
  id: ID
  name: String
}

input ItemTypeUpdateOneRequiredWithoutItemsInput {
  connect: ItemTypeWhereUniqueInput
  create: ItemTypeCreateWithoutItemsInput
  update: ItemTypeUpdateWithoutItemsDataInput
  upsert: ItemTypeUpsertWithoutItemsInput
}

input ItemTypeUpdateWithoutItemsDataInput {
  id: ID
  name: String
}

input ItemTypeUpsertWithoutItemsInput {
  create: ItemTypeCreateWithoutItemsInput!
  update: ItemTypeUpdateWithoutItemsDataInput!
}

input ItemTypeWhereInput {
  AND: [ItemTypeWhereInput!]
  id: StringFilter
  items: ItemFilter
  name: StringFilter
  NOT: [ItemTypeWhereInput!]
  OR: [ItemTypeWhereInput!]
}

input ItemTypeWhereUniqueInput {
  id: ID
}

input ItemUpdateInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceUpdateOneWithoutItemsInput
  locatedIn: RoomUpdateOneWithoutItemsInput
  name: String
  price: Float
  purchaseDate: DateTime
  type: ItemTypeUpdateOneRequiredWithoutItemsInput
  updatedAt: DateTime
}

input ItemUpdateManyDataInput {
  createdAt: DateTime
  id: ID
  name: String
  price: Float
  purchaseDate: DateTime
  updatedAt: DateTime
}

input ItemUpdateManyMutationInput {
  createdAt: DateTime
  id: ID
  name: String
  price: Float
  purchaseDate: DateTime
  updatedAt: DateTime
}

input ItemUpdateManyWithoutInvoiceInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutInvoiceInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutInvoiceInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutInvoiceInput!]
}

input ItemUpdateManyWithoutLocatedInInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutLocatedInInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutLocatedInInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutLocatedInInput!]
}

input ItemUpdateManyWithoutTypeInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutTypeInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutTypeInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutTypeInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  data: ItemUpdateManyDataInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateWithoutInvoiceDataInput {
  createdAt: DateTime
  id: ID
  locatedIn: RoomUpdateOneWithoutItemsInput
  name: String
  price: Float
  purchaseDate: DateTime
  type: ItemTypeUpdateOneRequiredWithoutItemsInput
  updatedAt: DateTime
}

input ItemUpdateWithoutLocatedInDataInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceUpdateOneWithoutItemsInput
  name: String
  price: Float
  purchaseDate: DateTime
  type: ItemTypeUpdateOneRequiredWithoutItemsInput
  updatedAt: DateTime
}

input ItemUpdateWithoutTypeDataInput {
  createdAt: DateTime
  id: ID
  invoice: InvoiceUpdateOneWithoutItemsInput
  locatedIn: RoomUpdateOneWithoutItemsInput
  name: String
  price: Float
  purchaseDate: DateTime
  updatedAt: DateTime
}

input ItemUpdateWithWhereUniqueWithoutInvoiceInput {
  data: ItemUpdateWithoutInvoiceDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithWhereUniqueWithoutLocatedInInput {
  data: ItemUpdateWithoutLocatedInDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithWhereUniqueWithoutTypeInput {
  data: ItemUpdateWithoutTypeDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutInvoiceInput {
  create: ItemCreateWithoutInvoiceInput!
  update: ItemUpdateWithoutInvoiceDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutLocatedInInput {
  create: ItemCreateWithoutLocatedInInput!
  update: ItemUpdateWithoutLocatedInDataInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutTypeInput {
  create: ItemCreateWithoutTypeInput!
  update: ItemUpdateWithoutTypeDataInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  invoice: InvoiceWhereInput
  locatedIn: RoomWhereInput
  name: StringFilter
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  price: FloatFilter
  purchaseDate: DateTimeFilter
  type: ItemTypeWhereInput
  updatedAt: DateTimeFilter
}

input ItemWhereUniqueInput {
  id: ID
}

type Mutation {
  createOneInvoice(data: InvoiceCreateInput!): Invoice!
  createOneItem(data: ItemCreateInput!): Item!
  createOneItemType(data: ItemTypeCreateInput!): ItemType!
  createOneRoom(data: RoomCreateInput!): Room!
  deleteOneInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOneItemType(where: ItemTypeWhereUniqueInput!): ItemType
  deleteOneRoom(where: RoomWhereUniqueInput!): Room
  updateManyInvoice(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  updateManyItemType(data: ItemTypeUpdateManyMutationInput!, where: ItemTypeWhereInput): BatchPayload!
  updateManyRoom(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  updateOneInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateOneItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateOneItemType(data: ItemTypeUpdateInput!, where: ItemTypeWhereUniqueInput!): ItemType
  updateOneRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
}

type Query {
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(after: ID, before: ID, first: Int, last: Int, skip: Int): [Invoice!]!
  item(where: ItemWhereUniqueInput!): Item
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
  itemType(where: ItemTypeWhereUniqueInput!): ItemType
  itemTypes(after: ID, before: ID, first: Int, last: Int, skip: Int): [ItemType!]!
  room(where: RoomWhereUniqueInput!): Room
  rooms(after: ID, before: ID, first: Int, last: Int, skip: Int): [Room!]!
}

type Room {
  floor: Floor!
  id: ID!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
  meetingRoom: Boolean!
  name: String!
}

input RoomCreateInput {
  floor: Floor!
  id: ID
  items: ItemCreateManyWithoutItemsInput
  meetingRoom: Boolean!
  name: String!
}

input RoomCreateOneWithoutLocatedInInput {
  connect: RoomWhereUniqueInput
  create: RoomCreateWithoutItemsInput
}

input RoomCreateWithoutItemsInput {
  floor: Floor!
  id: ID
  meetingRoom: Boolean!
  name: String!
}

input RoomUpdateInput {
  floor: Floor
  id: ID
  items: ItemUpdateManyWithoutLocatedInInput
  meetingRoom: Boolean
  name: String
}

input RoomUpdateManyMutationInput {
  floor: Floor
  id: ID
  meetingRoom: Boolean
  name: String
}

input RoomUpdateOneWithoutItemsInput {
  connect: RoomWhereUniqueInput
  create: RoomCreateWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  update: RoomUpdateWithoutItemsDataInput
  upsert: RoomUpsertWithoutItemsInput
}

input RoomUpdateWithoutItemsDataInput {
  floor: Floor
  id: ID
  meetingRoom: Boolean
  name: String
}

input RoomUpsertWithoutItemsInput {
  create: RoomCreateWithoutItemsInput!
  update: RoomUpdateWithoutItemsDataInput!
}

input RoomWhereInput {
  AND: [RoomWhereInput!]
  floor: Floor
  id: StringFilter
  items: ItemFilter
  meetingRoom: BooleanFilter
  name: StringFilter
  NOT: [RoomWhereInput!]
  OR: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}
